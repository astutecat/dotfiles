{
	"lv_mount": {
		"prefix": "mount",
		"body": [
			"def mount(_params, _session, socket) do",
			"  socket = assign(socket, ${1:key}: ${2:value})",
			"  {:ok, socket}",
			"end"
		],
		"description": "LiveView mount function"
	},
	"lv_rend": {
		"prefix": "rend",
		"body": [
			"def render(assigns) do",
			"  ~L\"\"\"",
			"  ${0}",
			"  \"\"\"",
			"end"
		],
		"description": "LiveView render function"
	},
	"lv_handle_event": {
		"prefix": "he",
		"body": [
			"def handle_event(${1:event}, _, socket) do",
			"  socket = assign(socket, ${2:key}: ${3:value})",
			"  {:noreply, socket}",
			"end"
		],
		"description": "LiveView handle_event function"
	},
	"lv_handle_info": {
		"prefix": "hi",
		"body": [
			"def handle_info(${1:message}, socket) do",
			"  socket = assign(socket, ${2:key}: ${3:value})",
			"  {:noreply, socket}",
			"end"
		],
		"description": "LiveView handle_info function"
	},
	"lv_handle_params": {
		"prefix": "hp",
		"body": [
			"def handle_params(params, _url, socket) do",
			"  {:noreply, socket}",
			"end"
		],
		"description": "LiveView handle_params function"
	},
	"lv_template": {
		"prefix": "lt",
		"body": [
			"~L\"\"\"",
			"${0}",
			"\"\"\""
		],
		"description": "LiveView inline template"
	},
	"lv_test_module": {
		"prefix": "lvtest",
		"body": [
			"defmodule LiveViewStudioWeb.${1}Test do",
			"  use LiveViewStudioWeb.ConnCase, async: true",
			"",
			"  import Phoenix.LiveViewTest",
			"",
			"  ${0}",
			"end"
		],
		"description": "LiveView test module"
	},
	"lv_test": {
		"prefix": "test",
		"body": [
			"test \"${1:description}\", %{conn: conn} do",
			"  {:ok, view, _html} = live(conn, \"${2:path}\")",
			"  ${0}",
			"end"
		],
		"description": "LiveView test"
	},
	"eex_datalist": {
		"prefix": "data",
		"body": [
			"<datalist id=\"${1}\">",
			"  ${0}",
			"</datalist>",
			""
		],
		"description": "EEx datalist"
	},
	"eex_input": {
		"prefix": "input",
		"body": [
			"<input type=\"text\" name=\"${1}\" value=\"${2}\"",
			"       placeholder=\"${3}\" />"
		],
		"description": "EEx text input"
	},
	"eex_hidden_input": {
		"prefix": "hidden",
		"body": [
			"<input type=\"hidden\" name=\"${1}\" value=\"${2}\" />"
		],
		"description": "EEx hidden input"
	},
	"eex_checkbox_input": {
		"prefix": "checkbox",
		"body": [
			"<input type=\"checkbox\" id=\"${1}\" name=\"${2}\" value=\"${3}\"/>"
		],
		"description": "EEx checkbox input"
	},
	"eex_render_block": {
		"prefix": "et",
		"body": [
			"<%= $1 %>"
		],
		"description": "<%= %> render block"
	},
	"eex_end_tag": {
		"prefix": "eend",
		"body": [
			"<% end %>$1"
		],
		"description": "<% end %> end tag"
	},
	"for": {
		"prefix": "efor",
		"body": [
			"<%= for ${1:item} <- @$1s do %>",
			"  $2",
			"<% end %>"
		],
		"description": "EEx for"
	},
	"fori": {
		"prefix": "efori",
		"body": [
			"<%= for ${1:item} <- @$1s do %>",
			"  $2",
			"<% end %>"
		],
		"description": "EEx for comprehension with items"
	},
	"eex_ifa": {
		"prefix": "eifa",
		"body": [
			"<%= if $1, do: \"{$1}\" %>"
		],
		"description": "EEx if for attribute"
	},
	"eex_if": {
		"prefix": "eif",
		"body": [
			"<%= if $1 do %>",
			"  $2",
			"<% end %>"
		],
		"description": "EEx if"
	},
	"eex_if_else": {
		"prefix": "eife",
		"body": [
			"<%= if $1 do %>",
			"  $2",
			"<% else %>",
			"  $3",
			"<% end %>"
		],
		"description": "EEx if else"
	},
	"eex_else": {
		"prefix": "eelse",
		"body": [
			"<% else %>"
		],
		"description": "EEx else"
	},
	"eex_cond": {
		"prefix": "econd",
		"body": [
			"<%= cond do %>",
			"  <% $1 -> %>",
			"    $2",
			"  <% true -> %>",
			"    $3",
			"<% end %>"
		],
		"description": "EEx cond"
	},
	"eex_unless": {
		"prefix": "eunless",
		"body": [
			"<%= unless $1 do %>",
			"  $2",
			"<% end %>"
		],
		"description": "EEx  unless"
	},
	"GenServer": {
    "prefix": "gen_server",
    "body": [
      "defmodule $1 do",
      "  use GenServer",
      "",
      "  def start_link(${init_args}) do",
      "    # you may want to register your server with `name: __MODULE__`",
      "    # as a third argument to `start_link`",
      "    GenServer.start_link(__MODULE__, [${init_args}])",
      "  end",
      "",
      "  def init(_args) do",
      "    {:ok, :initial_state}",
      "  end",
      "end"
    ],
    "description": "Insert code for a OTP GenServer",
    "scope": "source.elixir"
  },
	"Supervisor": {
    "prefix": "supervisor",
    "body": [
      "defmodule $1 do",
      "  use Supervisor",
      "",
      "  def start_link(${args}) do",
      "    Supervisor.start_link(__MODULE__, [${args}], name: __MODULE__)",
      "  end",
      "",
      "  def init([${args}]) do",
      "    children = []",
      "",
      "    Supervisor.init(children, strategy: :one_for_one)",
      "  end",
      "end"
    ],
    "description": "Insert code for an OTP Supervisor",
    "scope": "source.elixir"
  },
  "DynamicSupervisor": {
    "prefix": "dynamic_supervisor",
    "body": [
      "defmodule $1 do",
      "  use DynamicSupervisor",
      "",
      "  def start_link(${init_args}) do",
      "    DynamicSupervisor.start_link(__MODULE__, [${init_args}], name: __MODULE__)",
      "  end",
      "",
      "  def start_child(${child_args}) do",
      "    child_spec = %{",
      "      id: ${ChildModule},",
      "      start: {${ChildModule}, :start_link, [${child_args}]},",
      "      restart: :transient,",
      "      shutdown: :brutal_kill,",
      "      type: :worker,",
      "      modules: [${ChildModule}],",
      "    }",
      "",
      "    DynamicSupervisor.start_child(__MODULE__, child_spec)",
      "  end",
      "",
      "  def init([${init_args}]) do",
      "    DynamicSupervisor.init(strategy: :one_for_one)",
      "  end",
      "end"
    ],
    "description": "Insert code for a DynamicSupervisor",
    "scope": "source.elixir"
  },
	"handle_info": {
		"prefix": "handle_info",
		"body": [
			"@impl GenServer",
			"def handle_info($1, state) do",
			"  $0",
			"  {:noreply, state}",
			"end"
		]
	},
	"handle_continue": {
		"prefix": "handle_continue",
		"body": [
			"@impl GenServer",
			"def handle_continue($1, state) do",
			"  $0",
			"  {:noreply, state}",
			"end"
		]
	},
	"handle_call": {
		"prefix": "handle_call",
		"body": [
			"@impl GenServer",
			"def handle_call($1, _from, state) do",
			"  $0",
			"  {:reply, :ok, state}",
			"end"
		]
	},
	"handle_cast": {
		"prefix": "handle_cast",
		"body": [
			"@impl GenServer",
			"def handle_cast($1, state) do",
			"  $0",
			"  {:noreply, state}",
			"end"
		]
	}
}
